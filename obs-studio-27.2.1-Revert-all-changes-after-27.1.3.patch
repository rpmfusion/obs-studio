From bd5a3f3229d7276ad118e76a2774647cdbacc944 Mon Sep 17 00:00:00 2001
From: Neal Gompa <ngompa@fedoraproject.org>
Date: Sat, 26 Feb 2022 07:56:30 -0500
Subject: [PATCH] linux-capture: Revert all changes after 27.1.3 to 27.2.1

This makes the PipeWire capture work properly on EL8 platforms.
---
 plugins/linux-capture/CMakeLists.txt     |   2 +-
 plugins/linux-capture/pipewire-capture.c |  13 +-
 plugins/linux-capture/pipewire.c         | 533 +++++------------------
 plugins/linux-capture/pipewire.h         |   1 -
 plugins/linux-capture/portal.c           |  16 -
 plugins/linux-capture/portal.h           |   1 -
 plugins/linux-capture/xcompcap-main.cpp  |  67 +--
 7 files changed, 112 insertions(+), 521 deletions(-)

diff --git a/plugins/linux-capture/CMakeLists.txt b/plugins/linux-capture/CMakeLists.txt
index ed4e9762a..baf57223d 100644
--- a/plugins/linux-capture/CMakeLists.txt
+++ b/plugins/linux-capture/CMakeLists.txt
@@ -46,7 +46,7 @@ set(linux-capture_LIBRARIES
 
 option(ENABLE_PIPEWIRE "Enable PipeWire support" ON)
 if(ENABLE_PIPEWIRE)
-	find_package(PipeWire 0.3.32 QUIET)
+	find_package(PipeWire QUIET)
 	find_package(Libdrm QUIET) # we require libdrm/drm_fourcc.h to build
 	find_package(Gio QUIET)
 
diff --git a/plugins/linux-capture/pipewire-capture.c b/plugins/linux-capture/pipewire-capture.c
index b94c8866b..72f0df581 100644
--- a/plugins/linux-capture/pipewire-capture.c
+++ b/plugins/linux-capture/pipewire-capture.c
@@ -51,11 +51,6 @@ static void pipewire_capture_destroy(void *data)
 	obs_pipewire_destroy(data);
 }
 
-static void pipewire_capture_save(void *data, obs_data_t *settings)
-{
-	obs_pipewire_save(data, settings);
-}
-
 static void pipewire_capture_get_defaults(obs_data_t *settings)
 {
 	obs_pipewire_get_defaults(settings);
@@ -110,8 +105,6 @@ static void pipewire_capture_video_render(void *data, gs_effect_t *effect)
 	obs_pipewire_video_render(data, effect);
 }
 
-static bool initialized = false;
-
 void pipewire_capture_load(void)
 {
 	uint32_t available_capture_types = portal_get_available_capture_types();
@@ -139,7 +132,6 @@ void pipewire_capture_load(void)
 		.get_name = pipewire_desktop_capture_get_name,
 		.create = pipewire_desktop_capture_create,
 		.destroy = pipewire_capture_destroy,
-		.save = pipewire_capture_save,
 		.get_defaults = pipewire_capture_get_defaults,
 		.get_properties = pipewire_capture_get_properties,
 		.update = pipewire_capture_update,
@@ -161,7 +153,6 @@ void pipewire_capture_load(void)
 		.get_name = pipewire_window_capture_get_name,
 		.create = pipewire_window_capture_create,
 		.destroy = pipewire_capture_destroy,
-		.save = pipewire_capture_save,
 		.get_defaults = pipewire_capture_get_defaults,
 		.get_properties = pipewire_capture_get_properties,
 		.update = pipewire_capture_update,
@@ -176,11 +167,9 @@ void pipewire_capture_load(void)
 		obs_register_source(&pipewire_window_capture_info);
 
 	pw_init(NULL, NULL);
-	initialized = true;
 }
 
 void pipewire_capture_unload(void)
 {
-	if (initialized)
-		pw_deinit();
+	pw_deinit();
 }
diff --git a/plugins/linux-capture/pipewire.c b/plugins/linux-capture/pipewire.c
index 07b94d439..6ba101078 100644
--- a/plugins/linux-capture/pipewire.c
+++ b/plugins/linux-capture/pipewire.c
@@ -22,7 +22,6 @@
 
 #include "portal.h"
 
-#include <util/darray.h>
 #include <util/dstr.h>
 
 #include <gio/gio.h>
@@ -36,11 +35,6 @@
 #include <spa/debug/format.h>
 #include <spa/debug/types.h>
 #include <spa/param/video/type-info.h>
-#include <spa/utils/result.h>
-
-#ifndef SPA_POD_PROP_FLAG_DONT_FIXATE
-#define SPA_POD_PROP_FLAG_DONT_FIXATE (1 << 4)
-#endif
 
 #define REQUEST_PATH "/org/freedesktop/portal/desktop/request/%s/obs%u"
 #define SESSION_PATH "/org/freedesktop/portal/desktop/session/%s/obs%u"
@@ -49,24 +43,28 @@
 	(sizeof(struct spa_meta_cursor) + sizeof(struct spa_meta_bitmap) + \
 	 width * height * 4)
 
-struct obs_pw_version {
-	int major;
-	int minor;
-	int micro;
-};
-
-struct format_info {
-	uint32_t spa_format;
-	uint32_t drm_format;
-	DARRAY(uint64_t) modifiers;
-};
+#define fourcc_code(a, b, c, d)                                \
+	((__u32)(a) | ((__u32)(b) << 8) | ((__u32)(c) << 16) | \
+	 ((__u32)(d) << 24))
+
+#define DRM_FORMAT_XRGB8888        \
+	fourcc_code('X', 'R', '2', \
+		    '4') /* [31:0] x:R:G:B 8:8:8:8 little endian */
+#define DRM_FORMAT_XBGR8888        \
+	fourcc_code('X', 'B', '2', \
+		    '4') /* [31:0] x:B:G:R 8:8:8:8 little endian */
+#define DRM_FORMAT_ARGB8888        \
+	fourcc_code('A', 'R', '2', \
+		    '4') /* [31:0] A:R:G:B 8:8:8:8 little endian */
+#define DRM_FORMAT_ABGR8888        \
+	fourcc_code('A', 'B', '2', \
+		    '4') /* [31:0] A:B:G:R 8:8:8:8 little endian */
 
 struct _obs_pipewire_data {
 	GCancellable *cancellable;
 
 	char *sender_name;
 	char *session_handle;
-	char *restore_token;
 
 	uint32_t pipewire_node;
 	int pipewire_fd;
@@ -83,14 +81,9 @@ struct _obs_pipewire_data {
 
 	struct pw_core *core;
 	struct spa_hook core_listener;
-	int server_version_sync;
-
-	struct obs_pw_version server_version;
 
 	struct pw_stream *stream;
 	struct spa_hook stream_listener;
-	struct spa_source *reneg;
-
 	struct spa_video_info format;
 
 	struct {
@@ -111,8 +104,6 @@ struct _obs_pipewire_data {
 	enum obs_pw_capture_type capture_type;
 	struct obs_video_info video_info;
 	bool negotiated;
-
-	DARRAY(struct format_info) format_info;
 };
 
 struct dbus_call_data {
@@ -124,35 +115,6 @@ struct dbus_call_data {
 
 /* auxiliary methods */
 
-static bool parse_pw_version(struct obs_pw_version *dst, const char *version)
-{
-	int n_matches = sscanf(version, "%d.%d.%d", &dst->major, &dst->minor,
-			       &dst->micro);
-	return n_matches == 3;
-}
-
-static bool check_pw_version(const struct obs_pw_version *pw_version, int major,
-			     int minor, int micro)
-{
-	if (pw_version->major != major)
-		return pw_version->major > major;
-	if (pw_version->minor != minor)
-		return pw_version->minor > minor;
-	return pw_version->micro >= micro;
-}
-
-static void update_pw_versions(obs_pipewire_data *obs_pw, const char *version)
-{
-	blog(LOG_INFO, "[pipewire] server version: %s", version);
-	blog(LOG_INFO, "[pipewire] library version: %s",
-	     pw_get_library_version());
-	blog(LOG_INFO, "[pipewire] header version: %s",
-	     pw_get_headers_version());
-
-	if (!parse_pw_version(&obs_pw->server_version, version))
-		blog(LOG_WARNING, "[pipewire] failed to parse server version");
-}
-
 static const char *capture_type_to_string(enum obs_pw_capture_type capture_type)
 {
 	switch (capture_type) {
@@ -298,10 +260,8 @@ static void destroy_session(obs_pipewire_data *obs_pw)
 	}
 
 	g_clear_pointer(&obs_pw->sender_name, bfree);
-	obs_enter_graphics();
 	g_clear_pointer(&obs_pw->cursor.texture, gs_texture_destroy);
 	g_clear_pointer(&obs_pw->texture, gs_texture_destroy);
-	obs_leave_graphics();
 	g_cancellable_cancel(obs_pw->cancellable);
 	g_clear_object(&obs_pw->cancellable);
 }
@@ -314,291 +274,73 @@ static inline bool has_effective_crop(obs_pipewire_data *obs_pw)
 		obs_pw->crop.height < obs_pw->format.info.raw.size.height);
 }
 
-static const struct {
-	uint32_t spa_format;
-	uint32_t drm_format;
-	enum gs_color_format gs_format;
-	bool swap_red_blue;
-	const char *pretty_name;
-} supported_formats[] = {
-	{
-		SPA_VIDEO_FORMAT_BGRA,
-		DRM_FORMAT_ARGB8888,
-		GS_BGRA,
-		false,
-		"ARGB8888",
-	},
-	{
-		SPA_VIDEO_FORMAT_RGBA,
-		DRM_FORMAT_ABGR8888,
-		GS_RGBA,
-		false,
-		"ABGR8888",
-	},
-	{
-		SPA_VIDEO_FORMAT_BGRx,
-		DRM_FORMAT_XRGB8888,
-		GS_BGRX,
-		false,
-		"XRGB8888",
-	},
-	{
-		SPA_VIDEO_FORMAT_RGBx,
-		DRM_FORMAT_XBGR8888,
-		GS_BGRX,
-		true,
-		"XBGR8888",
-	},
-};
-
-#define N_SUPPORTED_FORMATS \
-	(sizeof(supported_formats) / sizeof(supported_formats[0]))
-
-static bool lookup_format_info_from_spa_format(
-	uint32_t spa_format, uint32_t *out_drm_format,
-	enum gs_color_format *out_gs_format, bool *out_swap_red_blue)
+static bool spa_pixel_format_to_drm_format(uint32_t spa_format,
+					   uint32_t *out_format)
 {
-	for (size_t i = 0; i < N_SUPPORTED_FORMATS; i++) {
-		if (supported_formats[i].spa_format != spa_format)
-			continue;
-
-		if (out_drm_format)
-			*out_drm_format = supported_formats[i].drm_format;
-		if (out_gs_format)
-			*out_gs_format = supported_formats[i].gs_format;
-		if (out_swap_red_blue)
-			*out_swap_red_blue = supported_formats[i].swap_red_blue;
-		return true;
-	}
-	return false;
-}
-
-static void swap_texture_red_blue(gs_texture_t *texture)
-{
-	GLuint gl_texure = *(GLuint *)gs_texture_get_obj(texture);
-
-	glBindTexture(GL_TEXTURE_2D, gl_texure);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_B, GL_RED);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_R, GL_BLUE);
-	glBindTexture(GL_TEXTURE_2D, 0);
-}
+	switch (spa_format) {
+	case SPA_VIDEO_FORMAT_RGBA:
+		*out_format = DRM_FORMAT_ABGR8888;
+		break;
 
-static inline struct spa_pod *build_format(struct spa_pod_builder *b,
-					   struct obs_video_info *ovi,
-					   uint32_t format, uint64_t *modifiers,
-					   size_t modifier_count)
-{
-	struct spa_pod_frame format_frame;
-
-	/* Make an object of type SPA_TYPE_OBJECT_Format and id SPA_PARAM_EnumFormat.
-	 * The object type is important because it defines the properties that are
-	 * acceptable. The id gives more context about what the object is meant to
-	 * contain. In this case we enumerate supported formats. */
-	spa_pod_builder_push_object(b, &format_frame, SPA_TYPE_OBJECT_Format,
-				    SPA_PARAM_EnumFormat);
-	/* add media type and media subtype properties */
-	spa_pod_builder_add(b, SPA_FORMAT_mediaType,
-			    SPA_POD_Id(SPA_MEDIA_TYPE_video), 0);
-	spa_pod_builder_add(b, SPA_FORMAT_mediaSubtype,
-			    SPA_POD_Id(SPA_MEDIA_SUBTYPE_raw), 0);
-
-	/* formats */
-	spa_pod_builder_add(b, SPA_FORMAT_VIDEO_format, SPA_POD_Id(format), 0);
-
-	/* modifier */
-	if (modifier_count > 0) {
-		struct spa_pod_frame modifier_frame;
-
-		/* build an enumeration of modifiers */
-		spa_pod_builder_prop(b, SPA_FORMAT_VIDEO_modifier,
-				     SPA_POD_PROP_FLAG_MANDATORY |
-					     SPA_POD_PROP_FLAG_DONT_FIXATE);
-
-		spa_pod_builder_push_choice(b, &modifier_frame, SPA_CHOICE_Enum,
-					    0);
-
-		/* The first element of choice pods is the preferred value. Here
-		 * we arbitrarily pick the first modifier as the preferred one.
-		 */
-		spa_pod_builder_long(b, modifiers[0]);
-
-		/* modifiers from  an array */
-		for (uint32_t i = 0; i < modifier_count; i++)
-			spa_pod_builder_long(b, modifiers[i]);
-
-		spa_pod_builder_pop(b, &modifier_frame);
-	}
-	/* add size and framerate ranges */
-	spa_pod_builder_add(b, SPA_FORMAT_VIDEO_size,
-			    SPA_POD_CHOICE_RANGE_Rectangle(
-				    &SPA_RECTANGLE(320, 240), // Arbitrary
-				    &SPA_RECTANGLE(1, 1),
-				    &SPA_RECTANGLE(8192, 4320)),
-			    SPA_FORMAT_VIDEO_framerate,
-			    SPA_POD_CHOICE_RANGE_Fraction(
-				    &SPA_FRACTION(ovi->fps_num, ovi->fps_den),
-				    &SPA_FRACTION(0, 1), &SPA_FRACTION(360, 1)),
-			    0);
-	return spa_pod_builder_pop(b, &format_frame);
-}
+	case SPA_VIDEO_FORMAT_RGBx:
+		*out_format = DRM_FORMAT_XBGR8888;
+		break;
 
-static bool build_format_params(obs_pipewire_data *obs_pw,
-				struct spa_pod_builder *pod_builder,
-				const struct spa_pod ***param_list,
-				uint32_t *n_params)
-{
-	uint32_t params_count = 0;
+	case SPA_VIDEO_FORMAT_BGRA:
+		*out_format = DRM_FORMAT_ARGB8888;
+		break;
 
-	const struct spa_pod **params;
-	params =
-		bzalloc(2 * obs_pw->format_info.num * sizeof(struct spa_pod *));
+	case SPA_VIDEO_FORMAT_BGRx:
+		*out_format = DRM_FORMAT_XRGB8888;
+		break;
 
-	if (!params) {
-		blog(LOG_ERROR,
-		     "[pipewire] Failed to allocate memory for param pointers");
+	default:
 		return false;
 	}
 
-	if (!check_pw_version(&obs_pw->server_version, 0, 3, 33))
-		goto build_shm;
-
-	for (size_t i = 0; i < obs_pw->format_info.num; i++) {
-		if (obs_pw->format_info.array[i].modifiers.num == 0) {
-			continue;
-		}
-		params[params_count++] = build_format(
-			pod_builder, &obs_pw->video_info,
-			obs_pw->format_info.array[i].spa_format,
-			obs_pw->format_info.array[i].modifiers.array,
-			obs_pw->format_info.array[i].modifiers.num);
-	}
-
-build_shm:
-	for (size_t i = 0; i < obs_pw->format_info.num; i++) {
-		params[params_count++] = build_format(
-			pod_builder, &obs_pw->video_info,
-			obs_pw->format_info.array[i].spa_format, NULL, 0);
-	}
-	*param_list = params;
-	*n_params = params_count;
 	return true;
 }
 
-static bool drm_format_available(uint32_t drm_format, uint32_t *drm_formats,
-				 size_t n_drm_formats)
-{
-	for (size_t j = 0; j < n_drm_formats; j++) {
-		if (drm_format == drm_formats[j]) {
-			return true;
-		}
-	}
-	return false;
-}
-
-static void init_format_info(obs_pipewire_data *obs_pw)
-{
-	da_init(obs_pw->format_info);
-
-	obs_enter_graphics();
-
-	enum gs_dmabuf_flags dmabuf_flags;
-	uint32_t *drm_formats = NULL;
-	size_t n_drm_formats;
-
-	bool capabilities_queried = gs_query_dmabuf_capabilities(
-		&dmabuf_flags, &drm_formats, &n_drm_formats);
-
-	for (size_t i = 0; i < N_SUPPORTED_FORMATS; i++) {
-		struct format_info *info;
-
-		if (!drm_format_available(supported_formats[i].drm_format,
-					  drm_formats, n_drm_formats))
-			continue;
-
-		info = da_push_back_new(obs_pw->format_info);
-		da_init(info->modifiers);
-		info->spa_format = supported_formats[i].spa_format;
-		info->drm_format = supported_formats[i].drm_format;
-
-		if (!capabilities_queried)
-			continue;
-
-		size_t n_modifiers;
-		uint64_t *modifiers = NULL;
-		if (gs_query_dmabuf_modifiers_for_format(
-			    supported_formats[i].drm_format, &modifiers,
-			    &n_modifiers)) {
-			da_push_back_array(info->modifiers, modifiers,
-					   n_modifiers);
-		}
-		bfree(modifiers);
-
-		if (dmabuf_flags &
-		    GS_DMABUF_FLAG_IMPLICIT_MODIFIERS_SUPPORTED) {
-			uint64_t modifier_implicit = DRM_FORMAT_MOD_INVALID;
-			da_push_back(info->modifiers, &modifier_implicit);
-		}
-	}
-	obs_leave_graphics();
-
-	bfree(drm_formats);
-}
-
-static void clear_format_info(obs_pipewire_data *obs_pw)
+static bool spa_pixel_format_to_obs_format(uint32_t spa_format,
+					   enum gs_color_format *out_format,
+					   bool *swap_red_blue)
 {
-	for (size_t i = 0; i < obs_pw->format_info.num; i++) {
-		da_free(obs_pw->format_info.array[i].modifiers);
+	switch (spa_format) {
+	case SPA_VIDEO_FORMAT_RGBA:
+		*out_format = GS_RGBA;
+		*swap_red_blue = false;
+		break;
+
+	case SPA_VIDEO_FORMAT_RGBx:
+		*out_format = GS_BGRX;
+		*swap_red_blue = true;
+		break;
+
+	case SPA_VIDEO_FORMAT_BGRA:
+		*out_format = GS_BGRA;
+		*swap_red_blue = false;
+		break;
+
+	case SPA_VIDEO_FORMAT_BGRx:
+		*out_format = GS_BGRX;
+		*swap_red_blue = false;
+		break;
+
+	default:
+		return false;
 	}
-	da_free(obs_pw->format_info);
-}
-
-static void remove_modifier_from_format(obs_pipewire_data *obs_pw,
-					uint32_t spa_format, uint64_t modifier)
-{
-	for (size_t i = 0; i < obs_pw->format_info.num; i++) {
-		if (obs_pw->format_info.array[i].spa_format != spa_format)
-			continue;
-
-		if (!check_pw_version(&obs_pw->server_version, 0, 3, 40)) {
-			da_erase_range(
-				obs_pw->format_info.array[i].modifiers, 0,
-				obs_pw->format_info.array[i].modifiers.num - 1);
-			continue;
-		}
 
-		int idx = da_find(obs_pw->format_info.array[i].modifiers,
-				  &modifier, 0);
-		while (idx != -1) {
-			da_erase(obs_pw->format_info.array[i].modifiers, idx);
-			idx = da_find(obs_pw->format_info.array[i].modifiers,
-				      &modifier, 0);
-		}
-	}
+	return true;
 }
 
-static void renegotiate_format(void *data, uint64_t expirations)
+static void swap_texture_red_blue(gs_texture_t *texture)
 {
-	UNUSED_PARAMETER(expirations);
-	obs_pipewire_data *obs_pw = (obs_pipewire_data *)data;
-	const struct spa_pod **params = NULL;
-
-	blog(LOG_DEBUG, "[pipewire] Renegotiating stream ...");
-
-	pw_thread_loop_lock(obs_pw->thread_loop);
-
-	uint8_t params_buffer[2048];
-	struct spa_pod_builder pod_builder =
-		SPA_POD_BUILDER_INIT(params_buffer, sizeof(params_buffer));
-	uint32_t n_params;
-	if (!build_format_params(obs_pw, &pod_builder, &params, &n_params)) {
-		teardown_pipewire(obs_pw);
-		pw_thread_loop_unlock(obs_pw->thread_loop);
-		return;
-	}
+	GLuint gl_texure = *(GLuint *)gs_texture_get_obj(texture);
 
-	pw_stream_update_params(obs_pw->stream, params, n_params);
-	pw_thread_loop_unlock(obs_pw->thread_loop);
-	bfree(params);
+	glBindTexture(GL_TEXTURE_2D, gl_texure);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_B, GL_RED);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_R, GL_BLUE);
+	glBindTexture(GL_TEXTURE_2D, 0);
 }
 
 /* ------------------------------------------------- */
@@ -645,7 +387,7 @@ static void on_process_cb(void *user_data)
 		uint32_t strides[planes];
 		uint64_t modifiers[planes];
 		int fds[planes];
-		bool use_modifiers;
+		bool modifierless; // DMA-BUF without explicit modifier
 
 		blog(LOG_DEBUG,
 		     "[pipewire] DMA-BUF info: fd:%ld, stride:%d, offset:%u, size:%dx%d",
@@ -654,9 +396,8 @@ static void on_process_cb(void *user_data)
 		     obs_pw->format.info.raw.size.width,
 		     obs_pw->format.info.raw.size.height);
 
-		if (!lookup_format_info_from_spa_format(
-			    obs_pw->format.info.raw.format, &drm_format, NULL,
-			    NULL)) {
+		if (!spa_pixel_format_to_drm_format(
+			    obs_pw->format.info.raw.format, &drm_format)) {
 			blog(LOG_ERROR,
 			     "[pipewire] unsupported DMA buffer format: %d",
 			     obs_pw->format.info.raw.format);
@@ -672,28 +413,19 @@ static void on_process_cb(void *user_data)
 
 		g_clear_pointer(&obs_pw->texture, gs_texture_destroy);
 
-		use_modifiers = obs_pw->format.info.raw.modifier !=
-				DRM_FORMAT_MOD_INVALID;
+		modifierless = obs_pw->format.info.raw.modifier ==
+			       DRM_FORMAT_MOD_INVALID;
 		obs_pw->texture = gs_texture_create_from_dmabuf(
 			obs_pw->format.info.raw.size.width,
 			obs_pw->format.info.raw.size.height, drm_format,
 			GS_BGRX, planes, fds, strides, offsets,
-			use_modifiers ? modifiers : NULL);
-
-		if (obs_pw->texture == NULL) {
-			remove_modifier_from_format(
-				obs_pw, obs_pw->format.info.raw.format,
-				obs_pw->format.info.raw.modifier);
-			pw_loop_signal_event(
-				pw_thread_loop_get_loop(obs_pw->thread_loop),
-				obs_pw->reneg);
-		}
+			modifierless ? NULL : modifiers);
 	} else {
 		blog(LOG_DEBUG, "[pipewire] Buffer has memory texture");
-		enum gs_color_format gs_format;
+		enum gs_color_format obs_format;
 
-		if (!lookup_format_info_from_spa_format(
-			    obs_pw->format.info.raw.format, NULL, &gs_format,
+		if (!spa_pixel_format_to_obs_format(
+			    obs_pw->format.info.raw.format, &obs_format,
 			    &swap_red_blue)) {
 			blog(LOG_ERROR,
 			     "[pipewire] unsupported DMA buffer format: %d",
@@ -704,7 +436,7 @@ static void on_process_cb(void *user_data)
 		g_clear_pointer(&obs_pw->texture, gs_texture_destroy);
 		obs_pw->texture = gs_texture_create(
 			obs_pw->format.info.raw.size.width,
-			obs_pw->format.info.raw.size.height, gs_format, 1,
+			obs_pw->format.info.raw.size.height, obs_format, 1,
 			(const uint8_t **)&buffer->datas[0].data, GS_DYNAMIC);
 	}
 
@@ -737,7 +469,7 @@ read_metadata:
 	obs_pw->cursor.valid = cursor && spa_meta_cursor_is_valid(cursor);
 	if (obs_pw->cursor.visible && obs_pw->cursor.valid) {
 		struct spa_meta_bitmap *bitmap = NULL;
-		enum gs_color_format gs_format;
+		enum gs_color_format format;
 
 		if (cursor->bitmap_offset)
 			bitmap = SPA_MEMBER(cursor, cursor->bitmap_offset,
@@ -745,8 +477,8 @@ read_metadata:
 
 		if (bitmap && bitmap->size.width > 0 &&
 		    bitmap->size.height > 0 &&
-		    lookup_format_info_from_spa_format(
-			    bitmap->format, NULL, &gs_format, &swap_red_blue)) {
+		    spa_pixel_format_to_obs_format(bitmap->format, &format,
+						   &swap_red_blue)) {
 			const uint8_t *bitmap_data;
 
 			bitmap_data =
@@ -760,7 +492,7 @@ read_metadata:
 					gs_texture_destroy);
 			obs_pw->cursor.texture = gs_texture_create(
 				obs_pw->cursor.width, obs_pw->cursor.height,
-				gs_format, 1, &bitmap_data, GS_DYNAMIC);
+				format, 1, &bitmap_data, GS_DYNAMIC);
 
 			if (swap_red_blue)
 				swap_texture_red_blue(obs_pw->cursor.texture);
@@ -781,7 +513,6 @@ static void on_param_changed_cb(void *user_data, uint32_t id,
 	obs_pipewire_data *obs_pw = user_data;
 	struct spa_pod_builder pod_builder;
 	const struct spa_pod *params[3];
-	uint32_t buffer_types;
 	uint8_t params_buffer[1024];
 	int result;
 
@@ -799,13 +530,6 @@ static void on_param_changed_cb(void *user_data, uint32_t id,
 
 	spa_format_video_raw_parse(param, &obs_pw->format.info.raw);
 
-	buffer_types = 1 << SPA_DATA_MemPtr;
-	bool has_modifier =
-		spa_pod_find_prop(param, NULL, SPA_FORMAT_VIDEO_modifier) !=
-		NULL;
-	if (has_modifier || check_pw_version(&obs_pw->server_version, 0, 3, 24))
-		buffer_types |= 1 << SPA_DATA_DmaBuf;
-
 	blog(LOG_DEBUG, "[pipewire] Negotiated format:");
 
 	blog(LOG_DEBUG, "[pipewire]     Format: %d (%s)",
@@ -842,7 +566,8 @@ static void on_param_changed_cb(void *user_data, uint32_t id,
 	/* Buffer options */
 	params[2] = spa_pod_builder_add_object(
 		&pod_builder, SPA_TYPE_OBJECT_ParamBuffers, SPA_PARAM_Buffers,
-		SPA_PARAM_BUFFERS_dataType, SPA_POD_Int(buffer_types));
+		SPA_PARAM_BUFFERS_dataType,
+		SPA_POD_Int((1 << SPA_DATA_MemPtr) | (1 << SPA_DATA_DmaBuf)));
 
 	pw_stream_update_params(obs_pw->stream, params, 3);
 
@@ -869,13 +594,6 @@ static const struct pw_stream_events stream_events = {
 	.process = on_process_cb,
 };
 
-static void on_core_info_cb(void *user_data, const struct pw_core_info *info)
-{
-	obs_pipewire_data *obs_pw = user_data;
-
-	update_pw_versions(obs_pw, info->version);
-}
-
 static void on_core_error_cb(void *user_data, uint32_t id, int seq, int res,
 			     const char *message)
 {
@@ -891,15 +609,16 @@ static void on_core_error_cb(void *user_data, uint32_t id, int seq, int res,
 
 static void on_core_done_cb(void *user_data, uint32_t id, int seq)
 {
+	UNUSED_PARAMETER(seq);
+
 	obs_pipewire_data *obs_pw = user_data;
 
-	if (id == PW_ID_CORE && obs_pw->server_version_sync == seq)
+	if (id == PW_ID_CORE)
 		pw_thread_loop_signal(obs_pw->thread_loop, FALSE);
 }
 
 static const struct pw_core_events core_events = {
 	PW_VERSION_CORE_EVENTS,
-	.info = on_core_info_cb,
 	.done = on_core_done_cb,
 	.error = on_core_error_cb,
 };
@@ -907,9 +626,9 @@ static const struct pw_core_events core_events = {
 static void play_pipewire_stream(obs_pipewire_data *obs_pw)
 {
 	struct spa_pod_builder pod_builder;
-	const struct spa_pod **params = NULL;
-	uint32_t n_params;
-	uint8_t params_buffer[2048];
+	const struct spa_pod *params[1];
+	uint8_t params_buffer[1024];
+	struct obs_video_info ovi;
 
 	obs_pw->thread_loop = pw_thread_loop_new("PipeWire thread loop", NULL);
 	obs_pw->context = pw_context_new(
@@ -935,17 +654,6 @@ static void play_pipewire_stream(obs_pipewire_data *obs_pw)
 	pw_core_add_listener(obs_pw->core, &obs_pw->core_listener, &core_events,
 			     obs_pw);
 
-	/* Signal to renegotiate */
-	obs_pw->reneg =
-		pw_loop_add_event(pw_thread_loop_get_loop(obs_pw->thread_loop),
-				  renegotiate_format, obs_pw);
-	blog(LOG_DEBUG, "[pipewire] registered event %p", obs_pw->reneg);
-
-	// Dispatch to receive the info core event
-	obs_pw->server_version_sync = pw_core_sync(obs_pw->core, PW_ID_CORE,
-						   obs_pw->server_version_sync);
-	pw_thread_loop_wait(obs_pw->thread_loop);
-
 	/* Stream */
 	obs_pw->stream = pw_stream_new(
 		obs_pw->core, "OBS Studio",
@@ -960,23 +668,33 @@ static void play_pipewire_stream(obs_pipewire_data *obs_pw)
 	pod_builder =
 		SPA_POD_BUILDER_INIT(params_buffer, sizeof(params_buffer));
 
-	obs_get_video_info(&obs_pw->video_info);
-
-	if (!build_format_params(obs_pw, &pod_builder, &params, &n_params)) {
-		pw_thread_loop_unlock(obs_pw->thread_loop);
-		teardown_pipewire(obs_pw);
-		return;
-	}
+	obs_get_video_info(&ovi);
+	params[0] = spa_pod_builder_add_object(
+		&pod_builder, SPA_TYPE_OBJECT_Format, SPA_PARAM_EnumFormat,
+		SPA_FORMAT_mediaType, SPA_POD_Id(SPA_MEDIA_TYPE_video),
+		SPA_FORMAT_mediaSubtype, SPA_POD_Id(SPA_MEDIA_SUBTYPE_raw),
+		SPA_FORMAT_VIDEO_format,
+		SPA_POD_CHOICE_ENUM_Id(
+			4, SPA_VIDEO_FORMAT_BGRA, SPA_VIDEO_FORMAT_RGBA,
+			SPA_VIDEO_FORMAT_BGRx, SPA_VIDEO_FORMAT_RGBx),
+		SPA_FORMAT_VIDEO_size,
+		SPA_POD_CHOICE_RANGE_Rectangle(
+			&SPA_RECTANGLE(320, 240), // Arbitrary
+			&SPA_RECTANGLE(1, 1), &SPA_RECTANGLE(8192, 4320)),
+		SPA_FORMAT_VIDEO_framerate,
+		SPA_POD_CHOICE_RANGE_Fraction(
+			&SPA_FRACTION(ovi.fps_num, ovi.fps_den),
+			&SPA_FRACTION(0, 1), &SPA_FRACTION(360, 1)));
+	obs_pw->video_info = ovi;
 
 	pw_stream_connect(
 		obs_pw->stream, PW_DIRECTION_INPUT, obs_pw->pipewire_node,
 		PW_STREAM_FLAG_AUTOCONNECT | PW_STREAM_FLAG_MAP_BUFFERS, params,
-		n_params);
+		1);
 
 	blog(LOG_INFO, "[pipewire] playing streamâ€¦");
 
 	pw_thread_loop_unlock(obs_pw->thread_loop);
-	bfree(params);
 }
 
 /* ------------------------------------------------- */
@@ -1090,20 +808,6 @@ static void on_start_response_received_cb(GDBusConnection *connection,
 	g_variant_iter_loop(&iter, "(u@a{sv})", &obs_pw->pipewire_node,
 			    &stream_properties);
 
-	if (portal_get_screencast_version() >= 4) {
-		g_autoptr(GVariant) restore_token = NULL;
-
-		g_clear_pointer(&obs_pw->restore_token, bfree);
-
-		restore_token = g_variant_lookup_value(result, "restore_token",
-						       G_VARIANT_TYPE_STRING);
-		if (restore_token)
-			obs_pw->restore_token = bstrdup(
-				g_variant_get_string(restore_token, NULL));
-
-		obs_source_save(obs_pw->source);
-	}
-
 	blog(LOG_INFO, "[pipewire] %s selected, setting up screencast",
 	     capture_type_to_string(obs_pw->capture_type));
 
@@ -1237,16 +941,6 @@ static void select_source(obs_pipewire_data *obs_pw)
 		g_variant_builder_add(&builder, "{sv}", "cursor_mode",
 				      g_variant_new_uint32(1));
 
-	if (portal_get_screencast_version() >= 4) {
-		g_variant_builder_add(&builder, "{sv}", "persist_mode",
-				      g_variant_new_uint32(2));
-		if (obs_pw->restore_token && *obs_pw->restore_token) {
-			g_variant_builder_add(
-				&builder, "{sv}", "restore_token",
-				g_variant_new_string(obs_pw->restore_token));
-		}
-	}
-
 	g_dbus_proxy_call(portal_get_dbus_proxy(), "SelectSources",
 			  g_variant_new("(oa{sv})", obs_pw->session_handle,
 					&builder),
@@ -1410,8 +1104,6 @@ static bool reload_session_cb(obs_properties_t *properties,
 
 	obs_pipewire_data *obs_pw = data;
 
-	g_clear_pointer(&obs_pw->restore_token, bfree);
-
 	teardown_pipewire(obs_pw);
 	destroy_session(obs_pw);
 
@@ -1431,14 +1123,10 @@ void *obs_pipewire_create(enum obs_pw_capture_type capture_type,
 	obs_pw->settings = settings;
 	obs_pw->capture_type = capture_type;
 	obs_pw->cursor.visible = obs_data_get_bool(settings, "ShowCursor");
-	obs_pw->restore_token =
-		bstrdup(obs_data_get_string(settings, "RestoreToken"));
 
 	if (!init_obs_pipewire(obs_pw))
 		g_clear_pointer(&obs_pw, bfree);
 
-	init_format_info(obs_pw);
-
 	return obs_pw;
 }
 
@@ -1450,21 +1138,12 @@ void obs_pipewire_destroy(obs_pipewire_data *obs_pw)
 	teardown_pipewire(obs_pw);
 	destroy_session(obs_pw);
 
-	g_clear_pointer(&obs_pw->restore_token, bfree);
-	clear_format_info(obs_pw);
-
 	bfree(obs_pw);
 }
 
-void obs_pipewire_save(obs_pipewire_data *obs_pw, obs_data_t *settings)
-{
-	obs_data_set_string(settings, "RestoreToken", obs_pw->restore_token);
-}
-
 void obs_pipewire_get_defaults(obs_data_t *settings)
 {
 	obs_data_set_default_bool(settings, "ShowCursor", true);
-	obs_data_set_default_string(settings, "RestoreToken", NULL);
 }
 
 obs_properties_t *obs_pipewire_get_properties(obs_pipewire_data *obs_pw,
diff --git a/plugins/linux-capture/pipewire.h b/plugins/linux-capture/pipewire.h
index 88ec76f37..975a1df64 100644
--- a/plugins/linux-capture/pipewire.h
+++ b/plugins/linux-capture/pipewire.h
@@ -35,7 +35,6 @@ void *obs_pipewire_create(enum obs_pw_capture_type capture_type,
 
 void obs_pipewire_destroy(obs_pipewire_data *obs_pw);
 
-void obs_pipewire_save(obs_pipewire_data *obs_pw, obs_data_t *settings);
 void obs_pipewire_get_defaults(obs_data_t *settings);
 
 obs_properties_t *obs_pipewire_get_properties(obs_pipewire_data *obs_pw,
diff --git a/plugins/linux-capture/portal.c b/plugins/linux-capture/portal.c
index f203470b6..1b0118f56 100644
--- a/plugins/linux-capture/portal.c
+++ b/plugins/linux-capture/portal.c
@@ -73,22 +73,6 @@ uint32_t portal_get_available_capture_types(void)
 	return available_source_types;
 }
 
-uint32_t portal_get_screencast_version(void)
-{
-	g_autoptr(GVariant) cached_version = NULL;
-	uint32_t version;
-
-	ensure_proxy();
-
-	if (!proxy)
-		return 0;
-
-	cached_version = g_dbus_proxy_get_cached_property(proxy, "version");
-	version = cached_version ? g_variant_get_uint32(cached_version) : 0;
-
-	return version;
-}
-
 GDBusConnection *portal_get_dbus_connection(void)
 {
 	ensure_proxy();
diff --git a/plugins/linux-capture/portal.h b/plugins/linux-capture/portal.h
index e26bdeabd..3178591be 100644
--- a/plugins/linux-capture/portal.h
+++ b/plugins/linux-capture/portal.h
@@ -24,7 +24,6 @@
 #include <gio/gio.h>
 
 uint32_t portal_get_available_capture_types(void);
-uint32_t portal_get_screencast_version(void);
 
 GDBusConnection *portal_get_dbus_connection(void);
 GDBusProxy *portal_get_dbus_proxy(void);
diff --git a/plugins/linux-capture/xcompcap-main.cpp b/plugins/linux-capture/xcompcap-main.cpp
index 5d78b529f..26aaa3689 100644
--- a/plugins/linux-capture/xcompcap-main.cpp
+++ b/plugins/linux-capture/xcompcap-main.cpp
@@ -4,7 +4,6 @@
 #include <X11/extensions/Xcomposite.h>
 #include <pthread.h>
 
-#include <algorithm>
 #include <vector>
 
 #include <obs-module.h>
@@ -58,13 +57,6 @@ obs_properties_t *XCompcapMain::properties()
 		props, "capture_window", obs_module_text("Window"),
 		OBS_COMBO_TYPE_LIST, OBS_COMBO_FORMAT_STRING);
 
-	struct WindowInfo {
-		std::string lex_comparable;
-		std::string name;
-		std::string desc;
-	};
-
-	std::vector<WindowInfo> window_strings;
 	for (Window win : XCompcap::getTopLevelWindows()) {
 		std::string wname = XCompcap::getWindowName(win);
 		std::string cls = XCompcap::getWindowClass(win);
@@ -72,28 +64,7 @@ obs_properties_t *XCompcapMain::properties()
 		std::string desc =
 			(winid + WIN_STRING_DIV + wname + WIN_STRING_DIV + cls);
 
-		std::string wname_lowercase = wname;
-		std::transform(wname_lowercase.begin(), wname_lowercase.end(),
-			       wname_lowercase.begin(),
-			       [](unsigned char c) { return std::tolower(c); });
-
-		window_strings.push_back({.lex_comparable = wname_lowercase,
-					  .name = wname,
-					  .desc = desc});
-	}
-
-	std::sort(window_strings.begin(), window_strings.end(),
-		  [](const WindowInfo &a, const WindowInfo &b) -> bool {
-			  return std::lexicographical_compare(
-				  a.lex_comparable.begin(),
-				  a.lex_comparable.end(),
-				  b.lex_comparable.begin(),
-				  b.lex_comparable.end());
-		  });
-
-	for (auto s : window_strings) {
-		obs_property_list_add_string(wins, s.name.c_str(),
-					     s.desc.c_str());
+		obs_property_list_add_string(wins, wname.c_str(), desc.c_str());
 	}
 
 	obs_properties_add_int(props, "cut_top", obs_module_text("CropTop"), 0,
@@ -200,12 +171,6 @@ struct XCompcapMain_private {
 	bool show_cursor = true;
 	bool cursor_outside = false;
 	xcursor_t *cursor = nullptr;
-	bool tick_error_suppressed = false;
-	// Whether to rebind the GLX Pixmap on every tick. This is the correct
-	// mode of operation, according to GLX_EXT_texture_from_pixmap. However
-	// certain drivers exhibits poor performance when this is done, so
-	// setting this to false allows working around it.
-	bool strict_binding = true;
 };
 
 XCompcapMain::XCompcapMain(obs_data_t *settings, obs_source_t *source)
@@ -214,11 +179,6 @@ XCompcapMain::XCompcapMain(obs_data_t *settings, obs_source_t *source)
 	p->source = source;
 
 	obs_enter_graphics();
-	if (strcmp(reinterpret_cast<const char *>(glGetString(GL_VENDOR)),
-		   "NVIDIA Corporation") == 0) {
-		// Pixmap binds are extremely slow on NVIDIA cards (https://github.com/obsproject/obs-studio/issues/5685)
-		p->strict_binding = false;
-	}
 	p->cursor = xcursor_init(xdisp);
 	obs_leave_graphics();
 
@@ -312,7 +272,7 @@ static void xcc_cleanup(XCompcapMain_private *p)
 		glBindTexture(GL_TEXTURE_2D, gltex);
 		if (p->glxpixmap) {
 			glXReleaseTexImageEXT(xdisp, p->glxpixmap,
-					      GLX_FRONT_EXT);
+					      GLX_FRONT_LEFT_EXT);
 			if (xlock.gotError()) {
 				blog(LOG_ERROR,
 				     "cleanup glXReleaseTexImageEXT failed: %s",
@@ -409,8 +369,6 @@ void XCompcapMain::updateSettings(obs_data_t *settings)
 
 	xcc_cleanup(p);
 
-	p->tick_error_suppressed = false;
-
 	if (settings) {
 		/* Settings initialized or changed */
 		const char *windowName =
@@ -567,7 +525,7 @@ void XCompcapMain::updateSettings(obs_data_t *settings)
 				     GS_GL_DUMMYTEX);
 	GLuint gltex = *(GLuint *)gs_texture_get_obj(p->gltex);
 	glBindTexture(GL_TEXTURE_2D, gltex);
-	glXBindTexImageEXT(xdisp, p->glxpixmap, GLX_FRONT_EXT, nullptr);
+	glXBindTexImageEXT(xdisp, p->glxpixmap, GLX_FRONT_LEFT_EXT, NULL);
 	if (xlock.gotError()) {
 		blog(LOG_ERROR, "glXBindTexImageEXT failed: %s",
 		     xlock.getErrorText().c_str());
@@ -633,7 +591,7 @@ void XCompcapMain::tick(float seconds)
 		p->win = 0;
 	}
 
-	XErrorLock xlock;
+	XDisplayLock xlock;
 	XWindowAttributes attr;
 
 	if (!p->win || !XGetWindowAttributes(xdisp, p->win, &attr)) {
@@ -664,22 +622,6 @@ void XCompcapMain::tick(float seconds)
 		XSync(xdisp, 0);
 	}
 
-	glBindTexture(GL_TEXTURE_2D, *(GLuint *)gs_texture_get_obj(p->gltex));
-	if (p->strict_binding) {
-		glXReleaseTexImageEXT(xdisp, p->glxpixmap, GLX_FRONT_EXT);
-		if (xlock.gotError() && !p->tick_error_suppressed) {
-			blog(LOG_ERROR, "glXReleaseTexImageEXT failed: %s",
-			     xlock.getErrorText().c_str());
-			p->tick_error_suppressed = true;
-		}
-		glXBindTexImageEXT(xdisp, p->glxpixmap, GLX_FRONT_EXT, nullptr);
-		if (xlock.gotError() && !p->tick_error_suppressed) {
-			blog(LOG_ERROR, "glXBindTexImageEXT failed: %s",
-			     xlock.getErrorText().c_str());
-			p->tick_error_suppressed = true;
-		}
-	}
-
 	if (p->include_border) {
 		gs_copy_texture_region(p->tex, 0, 0, p->gltex, p->cur_cut_left,
 				       p->cur_cut_top, width(), height());
@@ -689,7 +631,6 @@ void XCompcapMain::tick(float seconds)
 				       p->cur_cut_top + p->border, width(),
 				       height());
 	}
-	glBindTexture(GL_TEXTURE_2D, 0);
 
 	if (p->cursor && p->show_cursor) {
 		xcursor_tick(p->cursor);
-- 
2.35.1

